<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<head>
  <link rel="stylesheet" href="../../css/snippet.css">
  <link rel="stylesheet" href="../../css/solution.css">
  <link rel="stylesheet" href="../../css/tab.css">
</head>
<body>
    <h1>LeetCode Problem</h1>
    <section class="section" style="--c: black">
        <question_title>56. Merge Intervals</question_title>
        <a href="https://leetcode.com/problems/merge-intervals/description/">Link to LeetCode</a>
        <question>
            Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
            
            Example 1:
            Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
            Output: [[1,6],[8,10],[15,18]]
            Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
        </question>
        <notes>
            <b>Analysis</b>
            The key to solve this problem is defining a Comparator first to sort the arraylist of Intevals.
        </notes>
        <snippet>
public List< Interval> merge(List<Interval> intervals) {
    if(intervals == null || intervals.size()<=1){
        return intervals;
    }
 
    Collections.sort(intervals, Comparator.comparing((Interval itl)->itl.start));
 
    List<Interval> result = new ArrayList<>();
    Interval t = intervals.get(0);
 
    for(int i=1; i< intervals.size(); i++){
        Interval c = intervals.get(i);
        if(c.start <= t.end){
            t.end = Math.max(t.end, c.end);
        }else{
            result.add(t);
            t = c;
        }
    }
 
    result.add(t);
 
    return result;
}
        </snippet>
    </section>
</body>
<script src="../../js/solution.js"> </script>
<script src="../../js/snippet.js"> </script>
<script src="../../js/footer.js"> </script>
</html>