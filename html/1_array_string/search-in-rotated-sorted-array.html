<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<head>
  <link rel="stylesheet" href="../../css/snippet.css">
  <link rel="stylesheet" href="../../css/solution.css">
  <link rel="stylesheet" href="../../css/tab.css">
</head>
<body>
    <h1>LeetCode Problem</h1>
    <section class="section" style="--c: black">
        <question_title>33. Search in Rotated Sorted Array</question_title>
        <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/">Link to LeetCode</a>
        <question>
            There is an integer array <x>nums</x> sorted in ascending order (with distinct values).

            Prior to being passed to your function, <x>nums</x> is possibly left rotated at an unknown index <x>k</x> (<x>1 <= k < nums.length</x>) such that the resulting array is <x>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</x> (0-indexed). For example, <x>[0,1,2,4,5,6,7]</x> might be left rotated by <x>3</x> indices and become <x>[4,5,6,7,0,1,2]</x>.

            Given the array <x>nums</x> after the possible rotation and an integer <x>target</x>, return the index of <x>target</x> if it is in <x>nums</x>, or <x>-1</x> if it is not in <x>nums</x>.

            You must write an algorithm with <x>O(log n)</x> runtime complexity.
        </question>
        <question>
            <b>Example 1:</b>
            Input: nums = [4,5,6,7,0,1,2], target = 0
            Output: 4
            
            <b>Example 2:</b>
            Input: nums = [4,5,6,7,0,1,2], target = 3
            Output: -1

            <b>Example 3:</b>
            Input: nums = [1], target = 0
            Output: -1
        </question>
        <notes>
            In order to use binary search on the rotated sorted array, we need to determine how to update the left and right pointers. There are two major cases as shown below:
            <img src="images/Search-in-Rotated-Sorted-Array-730x362.png" alt="search-in-rotated-sorted-array"/>
            Once the two cases are identified, the problem is straightforward to solve. We only need to check if the target element is in the sorted side, and based on that move left or right pointers.
        </notes>
        <snippet>
public int search(int[] nums, int target) {
    int left = 0;
    int right= nums.length-1;
 
    while(left<=right){
        int mid = left + (right-left)/2;
        if(target==nums[mid])
            return mid;
 
        if(nums[left]<=nums[mid]){
            if(nums[left]<=target&& target< nums[mid]){
                right=mid-1;
            }else{
                left=mid+1;
            }
        }else{
            if(nums[mid]< target&& target<=nums[right]){
                left=mid+1;
            }else{
                right=mid-1;
            }
        }    
    }
    return -1;
}
        </snippet>
    </section>
</body>
<script src="../../js/solution.js"> </script>
<script src="../../js/snippet.js"> </script>
<script src="../../js/footer.js"> </script>
</html>